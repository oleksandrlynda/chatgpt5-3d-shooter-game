<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Block Strike 3D</title>
<style>
  :root{ --ui:#0f172a; --panel:#ffffffee; --accent:#22c55e; --warn:#ef4444; }
  html,body{height:100%}
  body{margin:0; overflow:hidden; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial; color:var(--ui);
        background: radial-gradient(120% 120% at 50% 0%, #aee9ff, #e9d5ff 60%, #ffe4ea);}
  #hud{ position:fixed; inset:0; pointer-events:none; display:flex; flex-direction:column; justify-content:space-between; padding:10px; }
  .row{ display:flex; gap:10px; align-items:center; }
  .pill{ pointer-events:auto; backdrop-filter: blur(10px); background:var(--panel); border:2px solid #00000018; border-radius:14px; padding:8px 12px; font-weight:800; box-shadow:0 10px 30px #00000022; }
  #center{ position:fixed; inset:0; display:grid; place-items:center; }
  #panel{ pointer-events:auto; width:min(92%,560px); text-align:center; background:var(--panel); border:3px solid #00000018; border-radius:22px; padding:22px; box-shadow:0 25px 80px #00000055; }
  h1{ margin:6px 0 4px; font-size: clamp(26px,5vw,44px);} h1 span{ color:#22c55e }
  button{ cursor:pointer; border:0; border-radius:14px; padding:12px 16px; font-weight:900; box-shadow:0 12px 36px #0000002a; }
  .primary{ background:linear-gradient(180deg,#22c55e,#86efac); color:#062e12 }
  .secondary{ background:linear-gradient(180deg,#60a5fa,#a5b4fc); color:#0b2458 }
  .tiny{ font-size:12px; opacity:.8 }
  #crosshair{ position:fixed; left:50%; top:50%; width:20px; height:20px; margin-left:-10px; margin-top:-10px; pointer-events:none; opacity:0.7 }
  #crosshair:before, #crosshair:after{ content:""; position:absolute; background:#0f172a; }
  #crosshair:before{ left:9px; top:0; bottom:0; width:2px; }
  #crosshair:after{ top:9px; left:0; right:0; height:2px; }
</style>
</head>
<body>
<div id="hud">
  <div class="row">
    <div class="pill">HP: <span id="hp">100</span></div>
    <div class="pill">Ammo: <span id="ammo">30</span>/<span id="mag">60</span></div>
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill" id="mute">üîä</div>
  </div>
  <div class="row" style="justify-content:flex-end">
    <div class="pill tiny">WASD move ‚Ä¢ Mouse aim ‚Ä¢ Click shoot ‚Ä¢ R reload ‚Ä¢ Shift sprint ‚Ä¢ Ctrl crouch ‚Ä¢ Space jump ‚Ä¢ P pause</div>
  </div>
</div>
<div id="crosshair"></div>
<div id="center"><div id="panel">
  <h1>Block <span>Strike</span> 3D</h1>
  <div>Lightweight FPS inspired by Counter‚ÄëStrike; simple blocks, fast rounds.</div>
  <div style="display:flex; gap:10px; justify-content:center; margin:12px 0; flex-wrap:wrap">
    <div class="pill">Waves of bots</div>
    <div class="pill">Hitscan rifle + tracers</div>
    <div class="pill">Headshot bonus</div>
    <div class="pill">Procedural arena</div>
  </div>
  <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap">
    <button class="primary" id="play">‚ñ∂Ô∏è Play</button>
    <button class="secondary" id="retry" style="display:none">üîÅ Retry</button>
  </div>
  <div class="tiny" style="margin-top:8px">Click Play, then click to lock the mouse.
  </div>
</div></div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/PointerLockControls.js?module';

// ------ Renderer & Scene ------
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0xcfe8ff, 20, 160);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);

// Gradient sky dome
const skyGeo = new THREE.SphereGeometry(300, 16, 8);
const skyMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  uniforms:{ top:{value:new THREE.Color('#aee9ff')}, bottom:{value:new THREE.Color('#f1e3ff')}, offset:{value:33}, exponent:{value:0.6} },
  vertexShader:`varying vec3 vWorldPosition; void main(){ vec4 p=modelMatrix*vec4(position,1.0); vWorldPosition=p.xyz; gl_Position=projectionMatrix*viewMatrix*p; }`,
  fragmentShader:`uniform vec3 top; uniform vec3 bottom; uniform float offset; uniform float exponent; varying vec3 vWorldPosition; void main(){ float h = normalize(vWorldPosition).y; float a = max(pow(max(h+offset,0.0), exponent), 0.0); gl_FragColor = vec4(mix(bottom, top, a), 1.0); }`
});
scene.add(new THREE.Mesh(skyGeo, skyMat));

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x4488aa, 0.9); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(20,30,10); scene.add(dir);

// ------ Controls ------
const controls = new PointerLockControls(camera, document.body);
controls.getObject().position.set(0, 1.7, 8);
scene.add(controls.getObject());

// Movement
const keys = new Set();
let moveSpeed = 6, sprintMult = 1.6; let canJump = false, velocityY = 0; const gravity = 20;
window.addEventListener('keydown', e=>{ keys.add(e.code); if(e.code==='Space' && canJump){ velocityY = 7; canJump = false; }
});
window.addEventListener('keyup', e=> keys.delete(e.code));

// ‚îÄ‚îÄ Smooth movement state
let vel = new THREE.Vector3();          // horizontal velocity (XZ)
const accel = 50;                       // acceleration strength
const damping = 10;                     // friction/drag when no input
let crouching = false;                  // crouch hold
const baseFov = 75, sprintFov = 82;     // FOV boost when sprinting

// crouch keys
window.addEventListener('keydown', e=>{ if(e.code==='ControlLeft'||e.code==='ControlRight') crouching=true; });
window.addEventListener('keyup', e=>{ if(e.code==='ControlLeft'||e.code==='ControlRight') crouching=false; });

// Resize
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
});

// ------ Arena ------
const objects = []; // collidable
const mats = {
  floor: new THREE.MeshLambertMaterial({ color:0xd7fbe8 }),
  wall:  new THREE.MeshLambertMaterial({ color:0x8ecae6 }),
  crate: new THREE.MeshLambertMaterial({ color:0xf6bd60 }),
  enemy: new THREE.MeshLambertMaterial({ color:0xef4444 }),
  head:  new THREE.MeshLambertMaterial({ color:0x111827 }),
  tracer: new THREE.LineBasicMaterial({ color:0x111111, transparent:true, opacity:1 }),
  spark: new THREE.MeshBasicMaterial({ color:0xffaa00 })
};

function makeArena(){
  // floor
  const floor = new THREE.Mesh(new THREE.BoxGeometry(80,1,80), mats.floor);
  floor.position.y = -0.5; floor.receiveShadow = true; scene.add(floor); // floor is NOT a blocker
  // outer walls (simple boxes)
  const wallH=6, wallT=1;
  const mkWall = (w,h,d,x,y,z)=>{ const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mats.wall); m.position.set(x,y,z); m.castShadow=true; m.receiveShadow=true; scene.add(m); objects.push(m); };
  mkWall(80, wallH, wallT, 0, wallH/2, -40);
  mkWall(80, wallH, wallT, 0, wallH/2,  40);
  mkWall(wallT, wallH, 80, -40, wallH/2, 0);
  mkWall(wallT, wallH, 80,  40, wallH/2, 0);
  // crates
  for(let i=0;i<18;i++){
    const b = new THREE.Mesh(new THREE.BoxGeometry(2+Math.random()*2, 2+Math.random()*2, 2+Math.random()*2), mats.crate);
    b.position.set((Math.random()*70-35)|0, b.geometry.parameters.height/2, (Math.random()*70-35)|0);
    scene.add(b); objects.push(b);
  }
}
makeArena();

// ------ Enemies ------
const enemies = new Set();
function spawnEnemy(){
  const body = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.6,1.2), mats.enemy);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.9,0.9), mats.head); head.position.y = 1.4; body.add(head);
  body.position.set((Math.random()*60-30)|0, 0.8, (Math.random()*60-30)|0);
  body.userData = { hp: 100, head, speed: 2.4 + Math.random()*0.8 };
  scene.add(body); enemies.add(body);
}

let wave=1, alive=0; function startWave(){ for(let i=0;i<3+wave;i++){ spawnEnemy(); } alive = enemies.size; }

// ------ Gun / Shooting ------
let ammo=30, mag=60, hp=100, score=0, paused=false, canShoot=true;
const hpEl = document.getElementById('hp'), ammoEl = document.getElementById('ammo'), magEl = document.getElementById('mag'), scoreEl = document.getElementById('score');
function updateHUD(){ hpEl.textContent=hp; ammoEl.textContent=ammo; magEl.textContent=mag; scoreEl.textContent=score; }
updateHUD();

// Sounds
const S = { ctx:null, muted:false, ensure(){ if(!this.ctx){ this.ctx=new (window.AudioContext||window.webkitAudioContext)(); } },
  b(f=440,t=0.07,g=0.18,type='square',slide=0){ if(this.muted) return; this.ensure(); const a=this.ctx; const o=a.createOscillator(); const G=a.createGain(); const n=a.currentTime; o.type=type; o.frequency.setValueAtTime(f,n); if(slide) o.frequency.exponentialRampToValueAtTime(Math.max(60,f+slide), n+t*0.9); G.gain.setValueAtTime(0.0001,n); G.gain.linearRampToValueAtTime(g,n+0.01); G.gain.exponentialRampToValueAtTime(0.0001,n+t); o.connect(G).connect(a.destination); o.start(n); o.stop(n+t); },
  shot(){ this.b(320,0.08,0.25,'sawtooth',-100); }, reload(){ this.b(660,0.15,0.2,'triangle'); }, hurt(){ this.b(200,0.2,0.22,'square'); }, kill(){ this.b(520,0.12,0.2,'triangle',60);} };
document.getElementById('mute').onclick=()=>{ S.muted=!S.muted; document.getElementById('mute').textContent=S.muted?'üîá':'üîä'; };

// Tracer + sparks
const tracers = [];
function addTracer(from, to){
  const g = new THREE.BufferGeometry().setFromPoints([from.clone(), to.clone()]);
  const line = new THREE.Line(g, mats.tracer.clone());
  line.userData = { life: 0 };
  scene.add(line); tracers.push(line);
}
function addSpark(at){
  const s = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), mats.spark.clone());
  s.position.copy(at); s.userData={ life:0 };
  scene.add(s); tracers.push(s); // reuse same update list
}

// Hitscan raycaster
const raycaster = new THREE.Raycaster();
function shoot(){ if(!canShoot || paused) return; if(ammo<=0){ S.reload(); return; } ammo--; S.shot(); updateHUD(); canShoot=false; setTimeout(()=>canShoot=true, 120);
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const origin = camera.getWorldPosition(new THREE.Vector3());
  raycaster.set(origin, dir);
  const candidates = [...enemies, ...objects];
  const hits = raycaster.intersectObjects(candidates, true);
  let end = origin.clone().add(dir.clone().multiplyScalar(80)); // default long shot
  if(hits.length){
    const hit = hits[0]; end.copy(hit.point);
    // find root enemy mesh
    let obj = hit.object; while(obj && !enemies.has(obj)){ obj = obj.parent; }
    if(obj){
      const isHead = hit.object === obj.userData.head;
      const dmg = isHead? 100 : 40; // headshot insta-kill
      obj.userData.hp -= dmg;
      // Knockback
      obj.position.add(dir.clone().multiplyScalar(0.2));
      addSpark(hit.point);
      if(obj.userData.hp<=0){ enemies.delete(obj); scene.remove(obj); alive--; score += isHead? 150:100; S.kill(); if(alive<=0){ wave++; startWave(); } updateHUD(); }
    } else {
      addSpark(hit.point);
    }
  }
  addTracer(origin, end);
}

window.addEventListener('mousedown', e=>{ if(!controls.isLocked) return; shoot(); });
window.addEventListener('keydown', e=>{
  if(e.code==='KeyR'){ if(ammo<30 && mag>0){ const need = Math.min(30-ammo, mag); ammo+=need; mag-=need; S.reload(); updateHUD(); } }
  if(e.code==='KeyP'){ paused=!paused; }
});

// ------ Game Loop ------
const clock = new THREE.Clock();
let gameOver=false;
function step(){
  const dt = Math.min(0.033, clock.getDelta());
  if(controls.isLocked && !paused && !gameOver){
    // smooth move (accel + damping + sprint FOV)
    const fo = controls.getObject();
    const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

    const wish = new THREE.Vector3();
    if (keys.has('KeyW')) wish.add(forward);
    if (keys.has('KeyS')) wish.add(forward.clone().multiplyScalar(-1));
    if (keys.has('KeyA')) wish.add(right.clone().multiplyScalar(-1));
    if (keys.has('KeyD')) wish.add(right);

    const sprinting = keys.has('ShiftLeft') || keys.has('ShiftRight');
    const targetSpeed = moveSpeed * (sprinting ? 1.6 : 1.0) * (crouching ? 0.55 : 1.0);

    if (wish.lengthSq() > 0) {
      wish.normalize().multiplyScalar(targetSpeed);
      const toAdd = wish.clone().sub(vel).clampLength(0, accel * dt);
      vel.add(toAdd);
    } else {
      const damp = Math.max(0, 1 - damping * dt);
      vel.multiplyScalar(damp);
    }

    const desiredFov = sprinting ? sprintFov : baseFov;
    camera.fov += (desiredFov - camera.fov) * 0.12; camera.updateProjectionMatrix();

    const next = fo.position.clone().add(vel.clone().multiplyScalar(dt));
    const blocked = objects.some(o=>{
      const bb = new THREE.Box3().setFromObject(o).expandByScalar(0.2);
      return bb.containsPoint(new THREE.Vector3(next.x, fo.position.y, next.z));
    });

    if(!blocked) fo.position.copy(next);

    // gravity + ground height (crouch-aware) + subtle head-bob
    const baseHeight = crouching ? 1.25 : 1.7;
    velocityY -= gravity * dt; fo.position.y += velocityY * dt;
    if (fo.position.y <= baseHeight) { fo.position.y = baseHeight; velocityY = 0; canJump = true; }
    const speed2D = vel.length();
    if (canJump && speed2D > 0.2) { fo.position.y += Math.sin(performance.now()*0.02) * 0.03; }

    // enemies AI
    for(const e of enemies){
      const toPlayer = fo.position.clone().sub(e.position); const dist = toPlayer.length();
      if(dist<2.1){ // melee
        hp -= 15*dt; if(hp<=0){ hp=0; gameOver=true; document.getElementById('retry').style.display=''; document.getElementById('center').style.display='grid'; S.hurt(); }
        updateHUD();
      }
      if(dist<40){ toPlayer.y=0; toPlayer.normalize(); e.position.add(toPlayer.multiplyScalar(e.userData.speed*dt)); }
    }
  }

  // update tracers & sparks fade
  for(let i=tracers.length-1;i>=0;i--){
    const obj = tracers[i]; obj.userData.life += dt;
    if(obj.isLine){ obj.material.opacity = Math.max(0, 1 - obj.userData.life/0.12); if(obj.userData.life>0.12){ scene.remove(obj); tracers.splice(i,1); } }
    else { // spark sphere expands & fades
      obj.scale.multiplyScalar(1 + dt*10);
      if(obj.material.opacity===undefined){ obj.material.transparent=true; obj.material.opacity=1; }
      obj.material.opacity = Math.max(0, 1 - obj.userData.life/0.25);
      if(obj.userData.life>0.25){ scene.remove(obj); tracers.splice(i,1); }
    }
  }

  renderer.render(scene,camera);
  requestAnimationFrame(step);
}
requestAnimationFrame(step);

// ------ UI / Flow ------
const panel = document.getElementById('panel');
const playBtn = document.getElementById('play');
const retryBtn = document.getElementById('retry');

function reset(){ // clear enemies
  for(const e of enemies){ scene.remove(e); } enemies.clear(); wave=1; alive=0; startWave();
  hp=100; ammo=30; mag=60; score=0; paused=false; gameOver=false; updateHUD();
  controls.getObject().position.set(0,1.7,8);
}

playBtn.onclick = ()=>{ panel.parentElement.style.display='none'; controls.lock(); reset(); };
retryBtn.onclick = ()=>{ panel.parentElement.style.display='none'; controls.lock(); reset(); };

controls.addEventListener('unlock', ()=>{ panel.parentElement.style.display='grid'; retryBtn.style.display=''; });

// Start with a wave ready so there's action immediately after lock
startWave();

// Ensure audio resume on first input (mobile/desktop)
window.addEventListener('pointerup', ()=> S.ensure(), {once:true});
</script>
</body>
</html>
